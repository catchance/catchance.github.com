[
    {
        "ref": "http://catchance.github.io/2017/mongodb/",
        "title": "mongodb",
        "keywords": ["mongodb","vim"],
        "section": "posts",
        "date" : "2017.07.03",
        "body": " mongodb基础知识、概念、与关系数据库的对比\nmongodb shell命令操作语法，控制台底层的查询语句都是用javascript脚本完成操作 java对于mongodb操作的方式：spring boot、morphia 使用示例和js脚本\n 概述 MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。\nMongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。\n关系数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。关系模型由关系数据结构、关系操作集合、关系完整性约束三部分组成。当前主流的关系型数据库有Oracle、DB2、PostgreSQL、Microsoft SQL Server、Microsoft Access、MySQL\nNoSQL，指的是非关系型的数据库。NoSQL有时也称作Not Only SQL的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称。分类有键值(Key-Value)存储数据库（Redis）、列存储数据库（HBase）、文档型数据库（MongoDb、SequoiaDB）、图形(Graph)数据库\n基本概念 MongoDB与SQL的相关概念对比\n   SQL术语/概念 MongoDB术语/概念 解释/说明     database database 数据库   table collection 数据库表/集合   row document 数据记录行/文档   column field 数据字段/域   index index 索引   table joins  表连接,MongoDB不支持   primary key primary key 主键,MongoDB自动将_id字段设置为主键     数据库  一个mongodb中可以建立多个数据库。 MongoDB的默认数据库为\u0026rdquo;db\u0026rdquo;，该数据库存储在data目录中。show dbs命令可以显示所有数据的列表。MongoDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限，不同的数据库也放置在不同的文件中。\n数据库也通过名字来标识。数据库名可以是满足以下条件的任意UTF-8字符串。 不能是空字符串（\u0026rdquo;\u0026ldquo;)。\n不得含有\u0026rsquo; \u0026lsquo;（空格)、.、$、/、\\和\\0 (空字符)。\n应全部小写。\n最多64字节。\nadmin： 从权限的角度来看，这是\u0026rdquo;root\u0026rdquo;数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。\nlocal: 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合\nconfig: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。\n$ mongo # mongo客户端命令 $ db # 显示当前数据库对象或集合 $ show dbs # 显示所有数据的列表 $ use local # 运行\u0026#34;use\u0026#34;命令，可以连接到一个指定的数据库。  文档\n  文档是一组键值(key-value)对(即BSON)。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。\n{ \u0026#34;key1\u0026#34;:\u0026#34;value1\u0026#34;, \u0026#34;key2\u0026#34;:\u0026#34;value2\u0026#34; } 注意：\n文档中的键/值对是有序的。\n文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。\nMongoDB区分类型和大小写。\nMongoDB的文档不能有重复的键。\n文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符。\n文档键命名规范：\n键不能含有\\0 (空字符)。这个字符用来表示键的结尾。\n.和$有特别的意义，只有在特定环境下才能使用。\n以下划线\u0026rdquo;_\u0026ldquo;开头的键是保留的(不是严格要求的)。\n 集合  集合就是 MongoDB 文档组，类似于 RDBMS （关系数据库管理系统：Relational Database Management System)中的表格。\n集合存在于数据库中，集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据，但通常情况下我们插入集合的数据都会有一定的关联性。\n{ \u0026#34;name\u0026#34;:\u0026#34;xxx\u0026#34; } { \u0026#34;name\u0026#34;:\u0026#34;yyy\u0026#34;,\u0026#34;age\u0026#34;:\u0026#34;20\u0026#34; } { \u0026#34;name\u0026#34;:\u0026#34;zzz\u0026#34;,\u0026#34;age\u0026#34;:\u0026#34;30\u0026#34; } 当第一个文档插入时，集合就会被创建。 合法的集合名\n集合名不能是空字符串\u0026rdquo;\u0026ldquo;。\n集合名不能含有\\0字符（空字符)，这个字符表示集合名的结尾。\n集合名不能以\u0026rdquo;system.\u0026ldquo;开头，这是为系统集合保留的前缀。\n用户创建的集合名字不能含有保留字符。有些驱动程序的确支持在集合名里面包含，这是因为某些系统生成的集合中包含该字符。除非你要访问这种系统创建的集合，否则千万不要在名字里出现$。\ncapped collections固定大小的collection\n它有很高的性能以及队列过期的特性(过期按照插入的顺序). 有点和 \u0026ldquo;RRD\u0026rdquo; 概念类似。\nCapped collections是高性能自动的维护对象的插入顺序。它非常适合类似记录日志的功能 和标准的collection不同，你必须要显式的创建一个capped collection， 指定一个collection的大小，单位是字节。collection的数据存储空间值提前分配的。\n要注意的是指定的存储大小包含了数据库的头信息。\ndb.createCollection(\u0026quot;mycoll\u0026quot;, {capped:true, size:100000}) 在capped collection中，你能添加新的对象。\n能进行更新，然而，对象不会增加存储空间。如果增加，更新就会失败 。 数据库不允许进行删除。使用drop()方法删除collection所有的行。 注意: 删除之后，你必须显式的重新创建这个collection。 在32bit机器中，capped collection最大存储为1e9( 1X109)个字节。\n判断集合是否为固定集合:db.cappedLogCollection.isCapped() 将已存在的集合转换为固定集合:db.runCommand({\u0026quot;convertToCapped\u0026quot;:\u0026quot;posts\u0026quot;,size:10000})\n固定集合文档按照插入顺序储存的,默认情况下查询就是按照插入顺序返回的,也可以使用$natural调整返回顺序。 db.cappedLogCollection.find().sort({$natural:-1})\n固定集合属性及用法\n属性\n属性1:对固定集合进行插入速度极快\n属性2:按照插入顺序的查询输出速度极快\n属性3:能够在插入最新数据时,淘汰最早的数据\n用法\n用法1:储存日志信息\n用法2:缓存一些少量的文档\n 元数据     集合命名空间 描述     dbname.system.namespaces 列出所有名字空间。   dbname.system.indexes 列出所有索引。   dbname.system.profile 包含数据库概要(profile)信息。   dbname.system.users 列出所有可访问数据库的用户。   dbname.local.sources 包含复制对端（slave）的服务器信息和状态。    在{{system.indexes}}插入数据，可以创建索引。但除此之外该表信息是不可变的(特殊的drop index命令将自动更新相关信息)。\n{{system.users}}是可修改的。 {{system.profile}}是可删除的。\n MongoDB 数据类型  |数据类型 | 描述| |\u0026ndash;|\u0026ndash;| |String| 字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。| |Integer | 整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。| |Boolean | 布尔值。用于存储布尔值（真/假）。| |Double | 双精度浮点值。用于存储浮点值。| |Min/Max keys | 将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。| |Arrays | 用于将数组或列表或多个值存储为一个键。| |Timestamp | 时间戳。记录文档修改或添加的具体时间。| |Object | 用于内嵌文档。| |Null | 用于创建空值。| |Symbol | 符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。| |Date | 日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。| |Object ID | 对象 ID。用于创建文档的 ID。| |Binary Data | 二进制数据。用于存储二进制数据。| |Code | 代码类型。用于在文档中存储 JavaScript 代码。| |Regular expression | 正则表达式类型。用于存储正则表达式。|\nNoSQL和SQL RDBMS - 高度组织化结构化数据 - 结构化查询语言（SQL） (SQL) - 数据和关系都存储在单独的表中。 - 数据操纵语言，数据定义语言 - 严格的一致性 - 基础事务 NoSQL - 代表着不仅仅是SQL - 没有声明性查询语言 - 没有预定义的模式 -键 - 值对存储，列存储，文档存储，图形数据库 - 最终一致性，而非ACID属性 - 非结构化和不可预知的数据 - CAP定理 指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼 - BASE(解决关系数据库强一致性引起的问题而引起的可用性降低而提出的解决方案) 基本可用（Basically Available）、软状态（Soft state）、最终一致（Eventually consistent） - 高性能，高可用性和可伸缩性\nNoSQL的优点/缺点 优点: - 高可扩展性 - 分布式计算 - 低成本 - 架构的灵活性，半结构化数据 - 没有复杂的关系 缺点: - 没有标准化 - 有限的查询功能（到目前为止） - 最终一致是不直观的程序\n使用场景  1、数据模型比较简单； 2、需要灵活性更强的IT系统； 3、对数据库性能要求较高； 4、不需要高度的数据一致性； 5、对于给定key，比较容易映射复杂值的环境。 6、事件的记录，内容管理或者博客平台  安装 ubuntu安装 # Ubuntu 16.04的安装 $ sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 0C49F3730359A14518585931BC711F9BA15703C6 $ echo \u0026#34;deb [ arch=amd64,arm64 ] http://repo.mongodb.org/apt/ubuntu xenial/mongodb-org/3.4 multiverse\u0026#34; | sudo tee /etc/apt/sources.list.d/mongodb-org-3.4.list $ sudo apt-get update $ sudo apt-get install -y mongodb-org # Run MongoDB Community Edition # /var/log/mongodb/mongod.log 日志文件 # /var/lib/mongodb data files # /etc/mongod.conf 配置文件, 27017为默认端口 # Start MongoDB. $ sudo service mongod start # Stop MongoDB. $ sudo service mongod stop # Restart MongoDB. $ sudo service mongod restart # Uninstall MongoDB Community Edition # Stop MongoDB. $ sudo service mongod stop # Remove Packages. $ sudo apt-get purge mongodb-org* # Remove Data Directories. $ sudo rm -r /var/log/mongodb $ sudo rm -r /var/lib/mongodb 基础操作 MongoDB - 连接 \u0026gt; mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]] \u0026gt; mongodb://localhost # 通过 shell 连接 MongoDB 服务： \u0026gt; mongo \u0026gt; mongodb://admin:123456@localhost/ \u0026gt; mongodb://admin:123456@localhost/test  mongodb:// 这是固定的格式，必须要指定。\nusername:password@ 可选项，如果设置，在连接数据库服务器之后，驱动都会尝试登陆这个数据库\nhost1 必须的指定至少一个host, host1 是这个URI唯一要填写的。它指定了要连接服务器的地址。如果要连接复制集，请指定多个主机地址。\nportX 可选的指定端口，如果不填，默认为27017\n/database 如果指定username:password@，连接并验证登陆指定数据库。若不指定，默认打开 test 数据库。\n?options 是连接选项。如果不使用/database，则前面需要加上/。所有连接选项都是键值对name=value，键值对之间通过\u0026amp;或;（分号）隔开\nMongoDB 数据库操作 # MongoDB 创建数据库的语法格式如下： # use DATABASE_NAME $ use xxx $ db.xxx.insert({\u0026#34;key\u0026#34;:\u0026#34;xxx\u0026#34;}) # MongoDB 删除数据库的语法格式如下： # db.dropDatabase() $ db.dropDatabase() # 集合删除语法格式如下：db.collection.drop() $ show tables 显示集合 $ db.xxx.drop() 数据导入导出和备份  导入cvs\n\u0026#34;C:\\Program Files\\MongoDB\\Server\\3.2\\bin\\mongoimport\u0026#34; /d drugOrg /c testtest /type:csv /headerline /file D:\\assign.csv \u0026#34;C:\\Program Files\\MongoDB\\Server\\3.2\\bin\\mongoimport\u0026#34; /d drugOrg /c t_signed /type:csv /headerline /file D:\\t_signed.csv 导出cvs\n\u0026#34;C:\\Program Files\\MongoDB\\Server\\3.2\\bin\\mongoexport\u0026#34; --csv -d drugOrg -c t_signed -o D:\\t_signed.csv \u0026#34;C:\\Program Files\\MongoDB\\Server\\3.2\\bin\\mongoexport\u0026#34; --csv -f _id,userId,companyId,time,singedTagId,department,day,orgId,userName,deviceId,tagNameList,treePath,headPicUrl,addressName,coordinate,address,visitId,country,province,city -d drugOrg -c t_signed -o D:\\t_signed.csv 还原数据库\n\u0026#34;C:\\Program Files\\MongoDB\\Server\\3.2\\bin\\mongorestore\u0026#34; -d drugOrg --drop D:\\drugOrg\\drugOrg  ObjectId ObjectId 是一个12字节 BSON 类型数据，有以下格式： - 前4个字节表示时间戳 - 接下来的3个字节是机器标识码 - 紧接的两个字节由进程id组成（PID） - 最后三个字节是随机数。 MongoDB中存储的文档必须有一个\u0026rdquo;_id\u0026rdquo;键。这个键的值可以是任何类型的，默认是个ObjectId对象。 在一个集合里面，每个文档都有唯一的\u0026rdquo;_id\u0026rdquo;值，来确保集合里面每个文档都能被唯一标识。 MongoDB采用ObjectId，而不是其他比较常规的做法（比如自动增加的主键）的主要原因，因为在多个 服务器上同步自动增加主键值既费力还费时。\n\u0026gt; newObjectId = ObjectId() \u0026gt; myObjectId = ObjectId(\u0026#34;5349b4ddd2781d08c09890f4\u0026#34;) \u0026gt; ObjectId(\u0026#34;5349b4ddd2781d08c09890f4\u0026#34;).getTimestamp() // 获取时间戳 \u0026gt; new ObjectId().str // ObjectId 转换成字符串  MongoDB 插入文档 # 插入文档 # db.COLLECTION_NAME.insert(document) \u0026gt; db.col.insert({ \u0026#34;title\u0026#34;: \u0026#34;MongoDB 教程\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;MongoDB 是一个 Nosql 数据库\u0026#34;, \u0026#34;by\u0026#34;: \u0026#34;菜鸟教程\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://www.runoob.com\u0026#34;, \u0026#34;tags\u0026#34;: [\u0026#34;mongodb\u0026#34;, \u0026#34;database\u0026#34;, \u0026#34;NoSQL\u0026#34;], \u0026#34;likes\u0026#34;: 100 }) \u0026gt; db.col.find() \u0026gt; document=({ \u0026#34;title\u0026#34;: \u0026#34;MongoDB 教程\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;MongoDB 是一个 Nosql 数据库\u0026#34;, \u0026#34;by\u0026#34;: \u0026#34;菜鸟教程\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://www.runoob.com\u0026#34;, \u0026#34;tags\u0026#34;: [\u0026#34;mongodb\u0026#34;, \u0026#34;database\u0026#34;, \u0026#34;NoSQL\u0026#34;], \u0026#34;likes\u0026#34;: 100 }); \u0026gt; document \u0026gt; db.col.insert(document) # 插入文档你也可以使用 db.col.save(document) 命令。 # 如果指定 _id 字段，则会更新该 _id 的数据。 # 3.2 版本后添加的方法 #db.collection.insertOne():向指定集合中插入一条文档数据 #db.collection.insertMany():向指定集合中插入多条文档数据 \u0026gt; var document = db.col.insertOne({\u0026#34;a\u0026#34;: 3}) \u0026gt; var res = db.col.insertMany([{\u0026#34;b\u0026#34;: 3}, {\u0026#34;c\u0026#34;: 4}]) MongoDB 更新文档 \u0026gt; db.collection.update( \u0026lt;query\u0026gt;, \u0026lt;update\u0026gt;, { upsert: \u0026lt;boolean\u0026gt;, multi: \u0026lt;boolean\u0026gt;, writeConcern: \u0026lt;document\u0026gt; } ) 参数说明： query : update的查询条件，类似sql update查询内where后面的。\nupdate : update的对象和一些更新的操作符（如$,$inc\u0026hellip;）等，也可以理解为sql update查询内set后面的\nupsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。\nmulti : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。\nwriteConcern :可选，抛出异常的级别。\n\u0026gt; db.col.update({\u0026#39;title\u0026#39;:\u0026#39;MongoDB 教程\u0026#39;},{$set:{\u0026#39;title\u0026#39;:\u0026#39;MongoDB\u0026#39;}}) \u0026gt; db.col.find().pretty() # save() 方法通过传入的文档来替换已有文档 \u0026gt; db.col.save({ \u0026#34;_id\u0026#34; : ObjectId(\u0026#34;596dfe19914215fcb553bfab\u0026#34;), \u0026#34;title\u0026#34; : \u0026#34;MongoDB\u0026#34;, \u0026#34;description\u0026#34; : \u0026#34;MongoDB 是一个 Nosql 数据库\u0026#34;, \u0026#34;by\u0026#34; : \u0026#34;Runoob\u0026#34;, \u0026#34;url\u0026#34; : \u0026#34;http://www.runoob.com\u0026#34;, \u0026#34;tags\u0026#34; : [ \u0026#34;mongodb\u0026#34;, \u0026#34;NoSQL\u0026#34; ], \u0026#34;likes\u0026#34; : 110 }) MongoDB 删除文档 db.collection.remove( \u0026lt;query\u0026gt;, { justOne: \u0026lt;boolean\u0026gt;, writeConcern: \u0026lt;document\u0026gt; } ) # 参数说明： # query :（可选）删除的文档的条件。 # justOne : （可选）如果设为 true 或 1，则只删除一个文档。 # writeConcern :（可选）抛出异常的级别。\u0026gt; db.col.remove({\u0026#39;title\u0026#39;:\u0026#39;MongoDB 教程\u0026#39;}) # 删除查询到的数据 \u0026gt; db.col.remove({}) #删除所有数据 \u0026gt; db.col.remove({\u0026#39;title\u0026#39;:\u0026#39;MongoDB\u0026#39;},1) MongoDB 查询文档 db.collection.find(query, projection) # query ：可选，使用查询操作符指定查询条件 # projection ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）。指定那些列显示和不显示（0表示不显示1表示显示) # pretty() 方法以格式化的方式来显示所有文档。 db.col.find().pretty() # 除了 find() 方法之外，还有一个 findOne() 方法，它只返回一个文档。\u0026gt; db.col.find().pretty() \u0026gt; db.col.find({},{\u0026#34;k1\u0026#34;:0,\u0026#34;k2\u0026#34;:2}).pretty()  MongoDB AND 条件 js // WHERE k1='v1' AND k2='v2' db.col.find({\u0026quot;k1\u0026quot;:\u0026quot;v1\u0026quot;, \u0026quot;k2\u0026quot;:\u0026quot;v2\u0026quot;}).pretty()  MongoDB OR 条件 js // WHERE k1=v1 OR k2 = v2 \u0026gt; db.col.find({ $or: [ {k1: v1}, {k2:v2} ] }).pretty()  AND 和 OR 联合使用\n// WHERE k1 \u0026gt; 50 AND (k2 = v2 OR k3 = v3) \u0026gt; db.col.find({ \u0026#34;k1\u0026#34;: {$gt:50}, $or: [{\u0026#34;k2\u0026#34;: \u0026#34;v2\u0026#34;},{\u0026#34;k3\u0026#34;: \u0026#34;v3\u0026#34;}] }).pretty()  使用 explain() 查询分析\ndb.users.find({gender:\u0026#34;M\u0026#34;},{user_name:1,_id:0}).explain()  现在，我们看看这个结果集的字段：\n indexOnly: 字段为 true ，表示我们使用了索引。 cursor：因为这个查询使用了索引，MongoDB 中索引存储在B树结构中，所以这是也使用了 BtreeCursor 类型的游标。如果没有使用索引，游标的类型是 BasicCursor。这个键还会给出你所使用的索引的名称，你通过这个名称可以查看当前数据库下的system.indexes集合（系统自动创建，由于存储索引信息，这个稍微会提到）来得到索引的详细信息。 n：当前查询返回的文档数量。 nscanned/nscannedObjects：表明当前这次查询一共扫描了集合中多少个文档，我们的目的是，让这个数值和返回文档的数量越接近越好。 millis：当前查询所需时间，毫秒数。 indexBounds：当前查询具体使用的索引。   // 可以使用 hint 来强制 MongoDB 使用一个指定的索引。 db.users.find({gender:\u0026#34;M\u0026#34;},{user_name:1,_id:0}).hint({gender:1,user_name:1}).explain()  MongoDB 正则表达式  正则表达式是使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。 许多程序设计语言都支持利用正则表达式进行字符串操作。 MongoDB 使用 $regex 操作符来设置匹配字符串的正则表达式。 MongoDB使用PCRE (Perl Compatible Regular Expression) 作为正则表达式语言。 不同于全文检索，我们使用正则表达式不需要做任何配置。 js db.posts.find({post_text:{$regex:\u0026quot;runoob\u0026quot;,$options:\u0026quot;$i\u0026quot;}})  数组元素使用正则表达式\n我们还可以在数组字段中使用正则表达式来查找内容。  优化正则表达式查询 - 如果你的文档中字段设置了索引，那么使用索引相比于正则表达式匹配查找所有的数据查询速度更快。 - 如果正则表达式是前缀表达式，所有匹配的数据将以指定的前缀字符串为开始。例如： 如果正则表达式为 ^tut ，查询语句将查找以 tut 为开头的字符串。\n注意： - 正则表达式中使用变量。一定要使用eval将组合的字符串进行转换，不能直接将字符串拼接后传入给表达式。否则没有报错信息，只是结果为空！实例如下：\nvar name=eval(\u0026#34;/\u0026#34; + 变量值key +\u0026#34;/i\u0026#34;); title:eval(\u0026#34;/\u0026#34;+title+\u0026#34;/i\u0026#34;) // 等同于 title:{$regex:title,$Option:\u0026#34;$i\u0026#34;}  MongoDB 条件操作符 |操作| 格式 | 范例 | RDBMS中的类似语句 | |\u0026ndash;|\u0026ndash;|\u0026ndash;|\u0026ndash;| |等于 | {:} | db.col.find({\u0026ldquo;by\u0026rdquo;:\u0026ldquo;菜鸟教程\u0026rdquo;}).pretty() | where by = \u0026lsquo;菜鸟教程\u0026rsquo;| |小于 | {:{$lt:}} | db.col.find({\u0026ldquo;likes\u0026rdquo;:{$lt:50}}).pretty() | where likes \u0026lt; 50 | |小于或等于 | {:{$lte:}} | db.col.find({\u0026ldquo;likes\u0026rdquo;:{$lte:50}}).pretty() | where likes \u0026lt;= 50| |大于 | {:{$gt:}} | db.col.find({\u0026ldquo;likes\u0026rdquo;:{$gt:50}}).pretty() | where likes \u0026gt; 50| |大于或等于 | {:{$gte:}} | db.col.find({\u0026ldquo;likes\u0026rdquo;:{$gte:50}}).pretty() | where likes \u0026gt;= 50| |不等于 | {:{$ne:}} | db.col.find({\u0026ldquo;likes\u0026rdquo;:{$ne:50}}).pretty() | where likes != 50\nMongoDB $type 操作符 // 查询col集合中 title 值类型为字符串的所有数据 db.col.find({\u0026#34;title\u0026#34; : {$type : 2}})  MongoDB简单查询操作符 | 操作 | 说明 | 示例 | |\u0026ndash;|\u0026ndash;|\u0026ndash;| |$eq | 用来等值条件过滤某一个key的值 | db.col.find({\u0026ldquo;name\u0026rdquo;:{$eq:\u0026ldquo;steven\u0026rdquo;}}) | |$gt | 用来判断某个key值大于某个指定的值 | db.col.find({\u0026ldquo;age\u0026rdquo;:{$gt:19}}) | |$gte | 用来判断某个key值大于等于某个指定的值 | db.col.find({\u0026ldquo;age\u0026rdquo;:{$gte:19}}) | |$lt | 用来判断某个key值小于某个指定的值 | db.col.find({\u0026ldquo;age\u0026rdquo;:{$lt:20}}) | |$lte | 用来判断某个key值小于等于某个指定的值 | db.col.find({\u0026ldquo;age\u0026rdquo;:{$lte:20}}) | |$ne | 用来不等值条件过滤某一个key的值。 | db.col.find({\u0026ldquo;name\u0026rdquo;:{$ne:\u0026ldquo;steven\u0026rdquo;}}) | |$in | 用来指定某个key的值在指定的离散的值域内 | db.col.find({\u0026ldquo;name\u0026rdquo;:{$in:[\u0026ldquo;steven\u0026rdquo;,\u0026ldquo;jack\u0026rdquo;]}}) | |$nin | 用来指定key值不存在某个指定的离散值域内 | db.col.find({\u0026ldquo;name\u0026rdquo;:{$nin:[\u0026ldquo;steven\u0026rdquo;,\u0026ldquo;jack\u0026rdquo;]}}) | |$or | 任意组合不同的查询条件（可以针对任意key的限制条件），只要满足任意组合条件中的一个即可。 | db.col.find({\u0026ldquo;$or\u0026rdquo; : [{\u0026ldquo;name\u0026rdquo;:\u0026ldquo;steven\u0026rdquo;},{\u0026ldquo;age\u0026rdquo;:20}]}) | |$and | 任意组合不同的查询条件（可以针对任意key的限制条件），并且必须同时满足所有条件。 | db.col.find({\u0026ldquo;$and\u0026rdquo; : [{\u0026ldquo;name\u0026rdquo;:\u0026ldquo;steven\u0026rdquo;},{\u0026ldquo;age\u0026rdquo;:20}]}) | |$not | 元条件语句，需要和其他条件语句组合使用。 | db.col.find({\u0026ldquo;age\u0026rdquo;:{\u0026ldquo;$not\u0026rdquo;:{\u0026ldquo;$lt\u0026rdquo;:20}}}) | |$nor | 表示所有条件均不能满足则返回 | db.col.find({\u0026ldquo;$nor\u0026rdquo; : [{\u0026ldquo;name\u0026rdquo;:\u0026ldquo;steven\u0026rdquo;},{\u0026ldquo;age\u0026rdquo;:20}]}) 凡是 name 为 steven 或者 age 为 20 的全部过滤掉 | |$exists | 查询不包含某一个属性（key）的文档 | db.col.find({\u0026ldquo;name\u0026rdquo;:{\u0026ldquo;$exists\u0026rdquo;:true}}) | |$mod | 取余操作符，筛选经过区域操作后，结果符合条件的文档。 | db.col.find({\u0026ldquo;age\u0026rdquo; : {\u0026ldquo;$mod\u0026rdquo; : [4,0]}}) 返回age的值和 4 求余后 结果为 0 的数据 | |$regex | 筛选值满足正则表达式的文档。 | db.col.find({\u0026ldquo;name\u0026rdquo; : {$regex:\u0026ldquo;stev*\u0026ldquo;,$options:\u0026ldquo;i\u0026rdquo;}}) | |$text | 针对建立了全文索引的字段，实施全文检索匹配。 | db.col.find({\u0026ldquo;$text\u0026rdquo;:{$search:\u0026ldquo;steven\u0026rdquo;,$language:\u0026ldquo;en\u0026rdquo;}}) | |$where | 强大的查询关键字，但性能较差，可以传入js表达式或js函数来筛选数据。 | 见下面 | |$all | 数组查询操作符，查询条件是一个数组，被查询的字段也是一个数组，要求被查询的数组类型的字段要是查询条件数组的超集（即大数组要包含小数组） | db.col.find({\u0026ldquo;values\u0026rdquo;:{$all:[\u0026ldquo;a\u0026rdquo;,\u0026ldquo;b\u0026rdquo;]}}) | |$elemMatch | 数组查询操作符，用来指定数组的每一个元素同时满足所罗列的条件，如果不指定，则条件会是或的关系 | db.blog.find({\u0026ldquo;comments\u0026rdquo;:{\u0026ldquo;$elemMatch\u0026rdquo;:{\u0026ldquo;author\u0026rdquo;:\u0026ldquo;joe\u0026rdquo;,\u0026ldquo;score\u0026rdquo;:{\u0026ldquo;$gte\u0026rdquo;:5}}}}) 查joe发表的5分以上的评论，注意comments为二维数组 | |$size | 用于某个数组类型的key对应值的数量满足要求。 | db.col.find({\u0026ldquo;values\u0026rdquo;:{$size : 3}}) | |$comment | 在查询、更新或其他操作执行过程中，可以通过添加$comment操作符添加评论。改评论会被记录在日志中，用于后续分析。 | db.col.find( { , $comment:  } ) | |$geoWithin | 这个操作符基于2d 空间索引，首先要针对文档的某个字段建立一个2d的空间索引，然后利用此操作符，可以在一个2d空间范围内指定一个多变形，$geoWithin操作符就是查询出包含在多变形范围内的点。 | | |$geoIntersects | 同样基于2d空间索引，计算当前的空间范围和指定的geo多变形取交集。 | | |$near | 基于2d空间索引，指定一个点，返回该点有近及远的所有的点。 | | |$nearSphere | 基于2d空间索引，指定一个点，由近及远的返回所有的点，和$near操作符不同的是计算距离的方式 $nearSphere计算的是球面距离。$near计算的是坐标距离。 | | | $ | 如果文档中某个value是数组类型，通过 $ 操作符可以指定数组字段的投影，返回数组字段中第一个匹配的那个元素，相当于截断了原来的整个数组，只返回第一个值。 | db.col.find({\u0026ldquo;values\u0026rdquo;:{$eq:\u0026ldquo;a\u0026rdquo;}},{\u0026ldquo;values.$\u0026rdquo;:1}) 会返回values数组中，第一个和\u0026rdquo;a\u0026rdquo;相等的元素，也就是返回\u0026rdquo;a\u0026rdquo; | |$meta | 和全文索引 text index 组合使用，针对一个带有全文索引的元素，指定改操作符，可以返回和查询条件相似的分数，分数越高，匹配度越高。 | | |$slice | 数组类型字段的投影操作，返回原来数据的一个子集.针对一个数组，其有如下几种返回子集的方式： | 示例如下 | |$cond | 聚合管道 | 示例如下 |\n// $where db.op_test.find({\u0026#34;$where\u0026#34;:function(){ for(var index in this) { if(this[index] == \u0026#34;steven\u0026#34;) { return true; } } return false; }}) // $slice db.blog.find({\u0026#34;comments\u0026#34;:{\u0026#34;$slice\u0026#34;:[10,5]}}) // $cond { \u0026#34;_id\u0026#34; : 1, \u0026#34;item\u0026#34; : \u0026#34;abc1\u0026#34;, qty: 300 } { \u0026#34;_id\u0026#34; : 2, \u0026#34;item\u0026#34; : \u0026#34;abc2\u0026#34;, qty: 200 } { \u0026#34;_id\u0026#34; : 3, \u0026#34;item\u0026#34; : \u0026#34;xyz1\u0026#34;, qty: 250 } db.inventory.aggregate( [ { $project: { item: 1, discount: { $cond: { if: { $gte: [ \u0026#34;$qty\u0026#34;, 250 ] }, then: 30, else: 20 } } } } ] ) { \u0026#34;_id\u0026#34; : 1, \u0026#34;item\u0026#34; : \u0026#34;abc1\u0026#34;, \u0026#34;discount\u0026#34; : 30 } { \u0026#34;_id\u0026#34; : 2, \u0026#34;item\u0026#34; : \u0026#34;abc2\u0026#34;, \u0026#34;discount\u0026#34; : 20 } { \u0026#34;_id\u0026#34; : 3, \u0026#34;item\u0026#34; : \u0026#34;xyz1\u0026#34;, \u0026#34;discount\u0026#34; : 30 }  MongoDB Limit与Skip方法 // db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER) // 查询第二条数据 // skip 默认为 0 limit默认为显示所有数据 // 当查询时同时使用sort,skip,limit，无论位置先后，最先执行顺序sort再skip再limit。 db.col.find({},{\u0026#34;title\u0026#34;:1,_id:0}).skip(1).limit(1)  MongoDB 排序 // db.COLLECTION_NAME.find().sort({KEY:1}) // 1 为升序排列，而-1是用于降序排列。 db.col.find({},{\u0026#34;title\u0026#34;:1,_id:0}).sort({\u0026#34;likes\u0026#34;:-1})  MongoDB 索引 索引是特殊的数据结构，索引存储在一个易于遍历读取的数据集合中，索引是对数据库表中一列或多列的值进行排序的一种结构\n// 建立索引的语法： db.COLLECTION_NAME.ensureIndex({KEY:1}) db.col.ensureIndex({\u0026#34;title\u0026#34;:1}) db.col.ensureIndex({\u0026#34;title\u0026#34;:1,\u0026#34;description\u0026#34;:-1}) // 类似于关系数据库中的复合索引 db.col.ensureIndex({\u0026#34;k1\u0026#34;: 1, \u0026#34;k2\u0026#34;: -1}, {\u0026#34;background\u0026#34;: true})  |Parameter | Type | Description | |\u0026ndash;|\u0026ndash;|\u0026ndash;| |background | Boolean | 建索引过程会阻塞其它数据库操作，background可指定以后台方式创建索引，即增加 \u0026ldquo;background\u0026rdquo; 可选参数。 \u0026ldquo;background\u0026rdquo; 默认值为false。 | |unique | Boolean | 建立的索引是否唯一。指定为true创建唯一索引。默认值为false. | |name | string | 索引的名称。如果未指定，MongoDB的通过连接索引的字段名和排序顺序生成一个索引名称。 | |dropDups | Boolean | 在建立唯一索引时是否删除重复记录,指定 true 创建唯一索引。默认值为 false. | |sparse | Boolean | 对文档中不存在的字段数据不启用索引；这个参数需要特别注意，如果设置为true的话，在索引字段中不会查询出不包含对应字段的文档.。默认值为 false. | |expireAfterSeconds | integer | 指定一个以秒为单位的数值，完成 TTL设定，设定集合的生存时间。| |v | index | version 索引的版本号。默认的索引版本取决于mongod创建索引时运行的版本。| |weights | document | 索引权重值，数值在 1 到 99,999 之间，表示该索引相对于其他索引字段的得分权重。| |default_language | string | 对于文本索引，该参数决定了停用词及词干和词器的规则的列表。 默认为英语 | |language_override | string | 对于文本索引，该参数指定了包含在文档中的字段名，语言覆盖默认的language，默认值为 language. |\n索引限制 - 额外开销 每个索引占据一定的存储空间，在进行插入，更新和删除操作时也需要对索引进行操作。所以，如果你很少对集合进行读取操作，建议不使用索引。 - 内存(RAM)使用 由于索引是存储在内存(RAM)中,你应该确保该索引的大小不超过内存的限制。 如果索引的大小大于内存的限制，MongoDB会删除一些索引，这将导致性能下降。 - 查询限制 索引不能被以下的查询使用： 正则表达式及非操作符，如 $nin, $not, 等。 算术运算符，如 $mod, 等。 - $where 子句 所以，检测你的语句是否使用索引是一个好的习惯，可以用explain来查看。 - 索引键限制 从2.6版本开始，如果现有的索引字段的值超过索引键的限制，MongoDB中不会创建索引。 - 插入文档超过索引键限制 如果文档的索引字段值超过了索引键的限制，MongoDB不会将任何文档转换成索引的集合。与mongorestore和mongoimport工具类似。 - 最大范围 集合中索引不能超过64个 索引名的长度不能超过128个字符 一个复合索引最多可以有31个字段\nMongoDB 聚合 db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION)  |表达式 | 描述 | 实例 | |\u0026ndash;|\u0026ndash;|\u0026ndash;| |$sum | 计算总和。| db.mycol.aggregate([{$group : {_id : \u0026ldquo;$by_user\u0026rdquo;, num_tutorial : {$sum : \u0026ldquo;$likes\u0026rdquo;}}}]) | |$avg | 计算平均值 | db.mycol.aggregate([{$group : {_id : \u0026ldquo;$by_user\u0026rdquo;, num_tutorial : {$avg : \u0026ldquo;$likes\u0026rdquo;}}}]) | |$min | 获取集合中所有文档对应值得最小值。| db.mycol.aggregate([{$group : {_id : \u0026ldquo;$by_user\u0026rdquo;, num_tutorial : {$min : \u0026ldquo;$likes\u0026rdquo;}}}]) | |$max | 获取集合中所有文档对应值得最大值。 | db.mycol.aggregate([{$group : {_id : \u0026ldquo;$by_user\u0026rdquo;, num_tutorial : {$max : \u0026ldquo;$likes\u0026rdquo;}}}]) | |$push | 在结果文档中插入值到一个数组中。 | db.mycol.aggregate([{$group : {_id : \u0026ldquo;$by_user\u0026rdquo;, url : {$push: \u0026ldquo;$url\u0026rdquo;}}}]) | |$addToSet | 在结果文档中插入值到一个数组中，但不创建副本。 | db.mycol.aggregate([{$group : {_id : \u0026ldquo;$by_user\u0026rdquo;, url : {$addToSet : \u0026ldquo;$url\u0026rdquo;}}}]) | |$first | 根据资源文档的排序获取第一个文档数据。| db.mycol.aggregate([{$group : {_id : \u0026ldquo;$by_user\u0026rdquo;, first_url : {$first : \u0026ldquo;$url\u0026rdquo;}}}]) | |$last | 根据资源文档的排序获取最后一个文档数据 | db.mycol.aggregate([{$group : {_id : \u0026ldquo;$by_user\u0026rdquo;, last_url : {$last : \u0026ldquo;$url\u0026rdquo;}}}]) |\n管道的概念 管道在Unix和Linux中一般用于将当前命令的输出结果作为下一个命令的参数。\nMongoDB的聚合管道将MongoDB文档在一个管道处理完毕后将结果传递给下一个管道处理。管道操作是可以重复的。\n表达式：处理输入文档并输出。表达式是无状态的，只能用于计算当前聚合管道的文档，不能处理其它的文档。\n这里我们介绍一下聚合框架中常用的几个操作：\n- $project：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。 - $match：用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。 - $limit：用来限制MongoDB聚合管道返回的文档数。 - $skip：在聚合管道中跳过指定数量的文档，并返回余下的文档。 - $unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。 - $group：将集合中的文档分组，可用于统计结果。 - $sort：将输入文档排序后输出。 - $geoNear：输出接近某一地理位置的有序文档。\n$project实例\n// 这样的话结果中就只还有_id,tilte和author三个字段了，默认情况下_id字段是被包含的，如果要想不包含_id话可以这样: // 非0显示；0不显示 db.col.aggregate( { $project : { title : 1 , author : 1 , }} );  $match实例\n// 用于获取分数大于70小于或等于90记录，然后将符合条件的记录送到下一阶段$group管道操作符进行处理。 db.col.aggregate( [ { $match : { score : { $gt : 70, $lte : 90 } } }, { $group: { _id: null, count: { $sum: 1 } } } ] );  $skip实例\n// 经过$skip管道操作符处理后，前五个文档被\u0026#34;过滤\u0026#34;掉。 db.col.aggregate( { $skip : 5 });  $group\n// select by_user as _id, count(*) as num_tutorial from mycol group by by_user db.col.aggregate([{$group : {_id : \u0026#34;$by_user\u0026#34;, num_tutorial : {$sum : 1}}}])  MongoDB 原子操作 mongodb不支持事务，所以，在你的项目中应用时，要注意这点。无论什么设计，都不要要求mongodb保证数据的完整性。 但是mongodb提供了许多原子操作，比如文档的保存，修改，删除等，都是原子操作。 所谓原子操作就是要么这个文档保存到Mongodb，要么没有保存到Mongodb，不会出现查询到的文档没有保存完整的情况。\ndb.books.findAndModify ( { query: { _id: 123456789, available: { $gt: 0 } }, update: { $inc: { available: -1 }, $push: { checkout: { by: \u0026#34;abc\u0026#34;, date: new Date() } } } } )  原子操作常用命令\n$set\n//用来指定一个键并更新键值，若键不存在并创建。 { $set : { \u0026#34;field\u0026#34; : \u0026#34;value\u0026#34; } }  $unset\n//用来删除一个键。 { $unset : { field : 1} }  $inc\n//$inc可以对文档的某个值为数字型（只能为满足要求的数字）的键进行增减的操作。 { $inc : { field : value } }  $push\n//用法： { $push : { field : value } } //把value追加到field里面去，field一定要是数组类型才行，如果field不存在，会新增一个数组类型加进去。  $pushAll\n//同$push,只是一次可以追加多个值到一个数组字段内。 { $pushAll : { field : value_array } }  $pull\n//从数组field内删除一个等于value值。 { $pull : { field : _value } }  $addToSet\n//增加一个值到数组内，而且只有当这个值不在数组内才增加。  $pop\n//删除数组的第一个或最后一个元素 { $pop : { field : 1 } }  $rename\n//修改字段名称 { $rename : { old_field_name : new_field_name } }  $bit\n//位操作，integer类型 {$bit : { field : {and : 5}}}  MongoDB Map Reduce MongoDB 全文检索 MongoDB GridFS GridFS 用于存储和恢复那些超过16M（BSON文件限制）的文件(如：图片、音频、视频等)。\nGridFS 也是文件存储的一种方式，但是它是存储在MonoDB的集合中。\nGridFS 可以更好的存储大于16M的文件。\nGridFS 会将大文件对象分割成多个小的chunk(文件片段),一般为256k/个,每个chunk将作为MongoDB的一个文档(document)被存储在chunks集合中。\nGridFS 用两个集合来存储一个文件：fs.files与fs.chunks。\n每个文件的实际内容被存在chunks(二进制数据)中,和文件有关的meta数据(filename,content_type,还有用户自定义的属性)将会被存在files集合中。\nGridFS 添加文件 现在我们使用 GridFS 的 put 命令来存储 mp3 文件。 调用 MongoDB 安装目录下bin的 mongofiles.exe工具。 打开命令提示符，进入到MongoDB的安装目录的bin目录中，找到mongofiles.exe，并输入下面的代码： \u0026gt;mongofiles.exe -d gridfs put song.mp3 GridFS 是存储文件的数据名称。如果不存在该数据库，MongoDB会自动创建。Song.mp3 是音频文件名。 使用以下命令来查看数据库中文件的文档： \u0026gt;db.fs.files.find() 以上命令执行后返回以下文档数据：\n{ _id: ObjectId(\u0026#39;534a811bf8b4aa4d33fdf94d\u0026#39;), filename: \u0026#34;song.mp3\u0026#34;, chunkSize: 261120, uploadDate: new Date(1397391643474), md5: \u0026#34;e4f53379c909f7bed2e9d631e15c1c41\u0026#34;, length: 10401959 }  我们可以看到 fs.chunks 集合中所有的区块，以下我们得到了文件的 _id 值，我们可以根据这个 _id 获取区块(chunk)的数据： \u0026gt;db.fs.chunks.find({files_id:ObjectId('534a811bf8b4aa4d33fdf94d')}) 以上实例中，查询返回了 40 个文档的数据，意味着mp3文件被存储在40个区块中。\n优化建议  在查询条件、排序条件、统计条件的字段上选择创建索引，可以显著提高查询效率。 用$or时把匹配最多结果的条件放在最前面，用$and时把匹配最 少 结果的条件放在最前面。 使用limit()限定返回结果集的大小，减少数据库服务器的资源消耗，以及网络传输的数据量。 尽量不用模糊匹配查询，用其它精确匹配查询代替，比如$in、$nin。 MongoDB的智能查询优化，判断粒度为query条件，而skip和limit都不在其判断之中，当分页查询最后几页时，先用order反向排序。 只查询要使用的字段，而不查询所有字段。 更新字段的值时，使用$inc比update效率高。 capped collections比普通collections的读写效率高。 必要时使用hint()强制使用某个索引查询。 使用explain，根据exlpain plan进行优化。 范围查询的时候尽量用$in、$nin代替。 查看数据库查询日志，具体分析的效率低的操作。 mongodb有一个数据库优化工具database profiler，能够检测数据库操作的性能。可以发现query或者write操作中执行效率低的，从而针对这些操作进行优化。  常用脚本  去重复的脚本 js db.b_doctor.aggregate([ { $group: {\u0026quot;_id\u0026quot;: { \u0026quot;doctorNum\u0026quot; : \u0026quot;$doctorNum\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;$name\u0026quot;},\u0026quot;countAll\u0026quot;:{$sum:1},\u0026quot;dups\u0026quot;:{$addToSet: '$_id'} }}, { $match:{ \u0026quot;countAll\u0026quot;:{$gt:1}}}]).forEach(function(doc){ doc.dups.shift(); db.b_doctor.remove({_id: {$in: doc.dups}}); })  同步表中的数据 js db.t_qa_question_hot.find({\u0026quot;questionType\u0026quot;:{$exists:false}}).forEach(function(x){ var cursor = db.t_qa_question.find({\u0026quot;_id\u0026quot;: ObjectId(x.questionId)}); if(cursor.hasNext()){ var q = cursor.next(); db.t_qa_question_hot.update({\u0026quot;_id\u0026quot;: x._id}, { $set:{\u0026quot;questionType\u0026quot; : NumberInt(q.type),\u0026quot;questionCreator\u0026quot;:q.userId}},false,true) } });  按照数组中的元素来进行分组统计 js // 如果$class_artist是数组 使用$unwind,它的功能就是把数组拆分出来，形成多条数据。 db.articles.aggregate([ {$match: { class_date: { $gte: date } } }, {$project: { _id: 0, class_artist: 1 } }, {$unwind: \u0026quot;$class_artist\u0026quot; }, {$group: { _id: \u0026quot;$class_artist\u0026quot;, tags: { $sum: 1 } }}, {$project: { _id: 0,class_artist: \u0026quot;$_id\u0026quot;, tags: 1 } }, {$sort: { tags: -1 } } ])   参考  官网 runoob.com \u0026gt;\u0026gt; MongoDB 教程 - "
    }
,
    {
        "ref": "http://catchance.github.io/about/",
        "title": "about",
        "keywords": null,
        "section": "",
        "date" : "2016.10.02",
        "body": " About me 热爱编程工作，喜欢做技术研究，有志将技术研发作为我的事业，有较强的学习能力，勇于创新，能快速适应环境，做事稳重，诚实，有责任心。具有较强的团队合作精神。待人真诚，热情，乐于助人。\n个人技能  熟练掌握Java编程语言和SQL结构化查询语言 熟练掌握HTML/CSS/JavaScript/JQuery/ajax/等前端技术 熟练掌握基于J2EE架构的JAVA Web编程：JavaBean、JSP、Servlet、JSTL、EL、JDBC编程Spring、SpringMVC、Struts2、Mybatis、Hibernate、MVC软件设计模式等技术 熟练使用轻量级的数据交换格式JSON和扩展标记语言XML进行数据交换 熟悉UML统一建模语言、项目管理工具Maven、Gradle和Idea、MyEclipse等IDE和团队协作开发工具SVN、GIT 熟悉主流Oracle、mysql数据库及基于进行应用程序的开发 熟悉Linux操作系统的常用命令、shell脚本、C语言编程 了解c++、groovy和swift等编程语言 了解查询英文帮助文档和源代码api的方式，可以阅读英文技术文档  兴趣爱好  爬山 徒步 看书 摄影  经历 深圳市大辰科技有限公司  深圳市大辰科技有限公司是国内最大的处方药制造和销售服务商投资的专注于移动医疗的互联网科技公司。团队由国内知名软件公司技术骨干为班底搭建，在信息系统构建、大数据、移动应用等领域具有丰富的实战经验。业务涵盖医生创业平台、医药F2C平台、网络医院等多种医疗新商业模式创新。\n 时间： 2016/05/09-目前 技术栈： - 前端：HTML/CSS/JavaScript/JQuery/ajax/Angularjs - 后台：Java/Spring/Struts2/Hibernate3/SpringMVC/Spring Boot/Redis/nginx/netty/spring cloud微服务解决方案框架 - 存储：Mysql/mongodb/SQL结构化查询语言 - 工具：idea/eclipse/svn/git/gitlab/MongoChef mongodb客户端/SmartGit/maven/Nexus(Maven私服)/JIRA（项目与事务跟踪工具）/Jenkins 集成构建工具/阿里云的企业邮箱/tomcat 服务器/NavicatforMySQL mysql客户端/postman 模拟Http发送工具/fiddler4 抓包工具/apidoc - 第三方类库：poi/dom4j/pinyin4j/junit/rest-assured/jedis/morphia/fastjson/logback/hibernate/quartz\n2017/6/27 - 目前 项目： - drugorg 1.7 、 1.7.1 、 1.7.2\n描述： 完成药企圈1.7版本的开发\n责任描述：\n2017/4/21 - 2017/6/27 项目： - drugorg 1.7 、 1.7.1 、 1.7.2 - signed\n描述： 完成药企圈1.7版本的开发\n责任描述： - 签到服务的签到地点查询优化（智能排序） - drugorg轻应用管理平台、轻应用服务相关 - 医药代表邀请医生好友功能 - 添加医药代表分管关系审核功能（分管品种审核员角色） - 完善推送通知功能 - 添加互助社区\u0026rdquo;热门\u0026rdquo;、\u0026rdquo;精华\u0026rdquo;栏目，重点一目了然 - 接受药企圈互助社区的项目\n2017/4/11- 2017/4/21 项目： - drugorg - signed - eda\n描述： 接手drugorg、signed、eda三个项目，完成项目架构改造，使用spring cloud的生态圈，\n责任描述： - 接手drugorg、signed、eda项目后台 - 完成drugorg消费者模式改造，使用ribbon - 完成zuul网关的改造\n2017/2/6- 2017/4/11 项目： - 药企圈交接 - eDA1.1\n描述： 增加年会红包的相关功能，药企圈的通讯录的优化，防止年会中多人抢红包拉取通讯录出现,交接药企圈的相关，全面接受eda项目，负责eda1.1项目的开发\n责任描述： - 年会红包相关的接口实现 - eda素材中添加对于音频文件的支持 - da.xml文件描述信息的增加 - 增加对于dda格式的支持，添加热区备注，回调 - 增加da的相关评价，品种组评价，客户评价，da整体评价 - 对于素材添加备注功能 - 增加对于演示中的画笔记录的保存，回放的功能 - 增加学习模式下面的留言反馈功能 - 优化da的文件协议，增加协议的版本信息 - 将项目往spring cloud中集成\n2016/12/14-2017/1/22 项目： - 药企圈1.5 - 药企圈辅助红包项目的相关优化\n描述： 增加年会红包的相关功能，药企圈的通讯录的优化，防止年会中多人抢红包拉取通讯录出现性能瓶颈问题、相关接口提供和修改，压力测试出性能问题的接口优化。用户加上缓存、离职方案修改, 修改轻引用的协议，以支持老版本的APP应用。\n责任描述： - 年会红包相关的接口实现 - 会务活动的相关药企圈的优化 - 配合压力测试\n2016/10/08-2016/12/13 项目： - eDA项目1.0 - 药企圈1.4优化\n描述：电子化的产品设计辅助系统旨在帮助医药企业的医药代表和市场人员在去医院给医生推广产品的时候一套辅助的推销系统。将设计好的产品推广文案更加生动形象在Ipad端展示给客户，提供更加丰富的体验。减少对于纸质文档的依赖。\n技术栈： - spring boot\n责任描述： - 登陆逻辑（二维码登陆和账号密码登陆都需要手机端程序确认） - 平台集成轻引用的相关服务：集成本地，第三方等轻应用的服务接口提供API - 和其他平台基础数据的同步，已经提供数据给各个端口使用 - 维护药企圈项目和增加新功能 - 七牛相关API的深入研究、自定义数据处理程序的编写Docker（Go语言的初步了解） - Qiniu解压zip、生成缩略图、打包、转码等相关服务（包括官方提供和自定义数据处理程序） - eDA项目的素材的基础增删改查基础数据处理 - Slide与素材之间的相关关系的业务逻辑处理 - Slide发布的相关业务逻辑（供APP端进行播放处理的DA的打包操作，生成ZIP文件发布到七牛服务器、生成da.xml数据结构） - Slide预览的相关接口（业务xml数据结构的生成） - 与Qiniu相关的交互服务（上传、处理数据、校验、异步任务、回调、缩略图、转码、在线解压） - 相关定时清理任务业务(清理上传page页面的数据、定时生成缩略图)\n2016/08/09-2016/10/01 项目： - 药企圈1.0 - 药企圈1.4 - 药企圈1.4优化\n描述： 药企圈是针对医药企业所做的一套员工办公社交系统。涵盖了员工之间的交流，电子工作文件管理，日常上班的签到打卡事务，客户拜访，会议直播等功能，医药品种管理，建议员工与医生之间的直接交流等常用功能。还涵盖了企业管理人员对于企业组织和员工的管理工作。包括了三个WEB、IOS和Android的应用程序。\n技术栈： - spring - springMVC\n责任描述： - 用户登陆等相关接口控制 - 企业信息增删改查等基础操作 - 组织树增删改查等基础操作（包括重构数据结构） - 组织人员增删改查基础操作、离职、人员角色（包括重构数据结构） - 职员批量导入 - APP端增量拉取、APP端第一次拉取职员缓存文件（包括性能优化） - 几次项目迁移重构（Hippo迁移、从玄关健康服务独立出微服务、重构、性能优化） - 基于底层token服务之上加入业务context认证，兼容以前的版本 - 验证码服务 - 内部通知公众号 - 拦截器权限校验服务 - 负责与药店圈的交互 - 通讯录拉取优化方案：生成增量的更新文件包，用户拉取更新时，可以拉取增量文件包 - 权限接口优化：对特定数据特定操作进行拦截判断权限业务级别 - 平台集成轻引用的相关服务：集成本地，第三方等轻应用的服务接口提供API - 和其他平台基础数据的同步，已经提供数据给各个端口使用 - 医生好友相关接口 - 微服务内部接口提供 - 医药代表分管品种 - 对外提供OpenAPI提供外部应用访问和同步数据\n2016/05/09-2016/08/08(试用期) 项目： - 玄关健康产品-药企组织项目迁移与修改 - 药企圈1.0\n描述： 这个项目是公司整个大项目的中一个微服务模块，主要对APP、Web和其他服务模块提供访问接口，涉及到的产品药企圈APP、药店圈APP、运营平台、企业管理平台四个平台，使用spring、springMVC等后台相关技术，以Http协议的方式对多端提供访问接口，使用Mongodb作为主要的数据库，主要包括分析、迁移、编码、修改、单元测试、回归测试修改Bug、运营维护。\n责任描述和收获： - 熟悉工作环境 - 熟悉开发环境和开发规范 - 主要负责企业相关的基础信息的CURD的操作，企业组织部门的CURD操作，企业用户相关关联操作，企业管理员、组织管理员、组织职员相关CURD操作。 - 企业包括药企（经营、生产）、药店(连锁总店药店、分店、单体药店) - 运营平台和药企药店平台 - 推广策略和推广活动 - 测试联调 - 配合产品测试调试与验证\n收获： 主要收获就是软件项目开发的规范化流程。后台开发只是对外提供访问接口，各个模块的联调沟通协调。 整个项目主要涉及到的部门有：运维架构部门（环境，构建，维护，网络）、Android端、IOS端、WEB端（Angularjs）、后台服务端（java EE）、测试部门、产品部门。 产品原型-规划接口-后台前端并行开发-联调接口-提交产品验证-测试-上线 开发环境-测试环境-生产测试环境-生产环境\n最主要的收获是对mongodb的了解与学习已经java操作mongodb的框架Morphia \u0026gt; 对于枚举和工具类的使用\n\u0026gt; java8的应用\n\u0026gt; 对外提供接口,最好单变量接口，不要使用对象包装，这样清晰明了\n\u0026gt; 不要讲一个方法写的太长，比如设置这样看能不能拆除方法\n\u0026gt; mongodb的事务非常不好处理\n\u0026gt; 注解生产接口文档非常有参考价值（Web API文档生成工具apidoc）\n\u0026gt; 多模块，微服务\n\u0026gt; 为了减轻服务器压力，能给客户端处理的数据，都可以交给客户端处理。 \u0026gt; 为防止模块之间相互依赖可以再controller调用其模块的任务，在service做判断，然后返回controller\n\u0026gt; mongodb先校验在进行操作，减少脏数据\n擎尚信息科技(上海)有限公司深圳分公司  擎尚信息科技(上海)有限公司是一家以智慧居家养老\u0026rdquo;服务模式“为老人提供\u0026rdquo;全天候、全方位、一站式\u0026rdquo;养老服务的网络科技软硬件公司。\n 时间： 2014\u0026frasl;09-2016\u0026frasl;05 工作描述： 参与项目前期设计规划、数据库设计、编码实现、单元测试、接口对接、后期维护及文档编写等。\n参与项目： - 上海海阳集团95002养老平台建设 - 上海海阳集团一卡通后台管理系统\n2015/03–2016/05 项目： 上海海阳集团一卡通后台管理系统\n描述： 一卡通后台管理系统主要针对对有需要服务老人进行派遣服务，刷卡收费管理。项目使用springmvc和mybatis框架架构，数据库为mysql。 - 项目分为：会员管理、卡片管理、商户商品管理、终端管理、结算中心、服务人员管理模块、权限管理。 - 会员管理：会员查询、添加批量导入等 - 卡片管理：卡片导入、查询、状态（开卡、挂失、销卡等） - 结算中心：卡片充值记录、消费记录、金额变动记录等\n技术栈： - 前端：HTML/CSS/JavaScript/JQuery/ajax - 后台：Java/Spring/SpringMVC/Mybatis3/JDBC/JSP/Servlet/EL - 存储：Mysql/SQL结构化查询语言 - 其他：JSON/XML - 工具：Maven/MyEclipse/svn\n责任描述： 负责与CRM系统进行的服务人员模块，包括添加服务人员，服务人员信息同步，服务人员地址信息交互，支付结果信息交互、卡片类型同步 负责与CRM系统案件信息进行交互\n2014\u0026frasl;09-2016\u0026frasl;05 项目： 上海海阳集团95002养老平台建设\n描述： 养老平台主要是以智慧居家养老\u0026rdquo;服务模式“为老人提供\u0026rdquo;全天候、全方位、一站式\u0026rdquo;养老服务。该项目有设备报警、接警中心、日常慰问、案件处理, 后台管理等功能模块。 设备报警:老人家里有可以报警的设备检查突发情况以向养老平台提供报警信息。 接警中心:养老平台拥有呼叫中心的功能接受老人的呼入电话帮助老人解决问题。 日常慰问:养老平台根据老人的数据提供日常的慰问工作。 案件处理：根据平台搜集到的信息，建立派工单安排工作人员上门进行服务。 后台管理: 部门，会员，统计，分布地图，系统设置等管理功能\n技术栈： - 前端：HTML/CSS/JavaScript/JQuery/ajax - 后台：Java/Spring/Struts2/Mybatis3/JDBC/JSP/Servlet/EL - 存储：Mysql- /SQL结构化查询语言 - 其他：JSON/XML - 工具：Maven/MyEclipse/svn\n责任描述： - 项目前期：负责maven搭建项目环境, 解决在项目集成中所出现的跟maven有关的错误.搭建nexus私有- 服务器，搭建jenkins集成开发环境，参与项目的规划，数据库表结构设计，项目基础接口的编写与实现。 - 码编阶段：负责接警中心，设备报警，案件处理，后台管理的相关查询的基础代码的编写工作。使用jcs作为项目的缓存框架将菜单权限等缓存起来。使用rmi实现和一卡通系统的对接工作，采用rmi实现多个分中心和总部的服务人员的同步工作。采用mina框架实现socket编程实现服务人员定位功能。 - 第三方对接：采用axis2调用webServers服务实现和民政局实现会员数据的同步和维护的工作。 - 后期维护：对地图模块进行性能优化，对各种错误进行修改，对于新增加的功能进行开发，将项目的构建工具改为gradle和git\n深圳市前沿体育科技发展有限公司(实习)  深圳市一线体育发展有限公司成立于2007年，在过去的6年中我们逐步的成长进步，公司相序和广东体育频道，欧洲足球频道、广州竞赛频道等强势媒体合作开展每日专题足彩、竞彩分析栏目。在全国体育赛事分析上面影响了颇大。公司目标：一、致力于做更好的体育信息互动平台，为体育产业市场化、信息化做出一份贡献；二、做专业的体育信息俱乐部及最好的体育信息产品平台。\n 时间： 2014\u0026frasl;02-2014\u0026frasl;09\n工作描述： 参与老项目的维护修改工作、新项目的规划设计、数据库设计、编码实现、测试、文档编写\n参与项目： 深圳前沿体育服务器后台建设\n2014\u0026frasl;02-2014\u0026frasl;09 项目： 深圳前沿体育服务器后台建设\n描述： 本系统是公司服务后台建设；用户通过手机App或Web端完成体育资讯获取或体育相关的电子商务活动,本系统应具有非常高的可扩展性，以适应将来用户增长和功能叠加带来的扩展需求。\n技术栈： - 前端：HTML CSS JavaScript JQuery ajax - 后台：Java Spring Struts2 Hibernate3 - 存储：Mysql SQL结构化查询语言 - 工具：MyEclipse10.7/svn\n责任描述： - 前期维护已有PHP的项目，了解PHP的基本语法。 - 重新设计产品协同项目经理进行需求分析和网站需求规格说明书的编写。 - 进行了内容表，栏目表，回复表，字内容表的设计。 - 了解项目经理的系统的整体架构等相关的技术。 - 辅助进行SSH环境的搭建、SVN版本控制搭建。 - 对于内容表、栏目表、子内容表进入代码编写。\n"
    }
]
